<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Preloader </title>
</head>
<body>

    <script>

// class Preloader {
//     constructor () {}
//     static series (imageArray) {        // 동기식(병렬처리)
//         let n = imageArray.length
//             for (let i = 0; i < n; i++) {
//             let img = new Image()
//             img.src = imageArray[i]
//         }
//     }
//     static parallel (imageArray, idx) { // 비동기식
//         let index = idx || 0
//         if (imageArray && imageArray.length > index) {
//             let img = new Image()
//             img.onload =()=> Preloader.parallel(imageArray, index + 1)
//             img.src = imageArray[index]
//         }
//     }
// }

// const images = [
//     "./img/img_1.jpg", "./img/img_2.jpg", "./img/img_3.jpg", "./img/img_4.jpg", "./img/img_5.jpg",
//     "./img/img_6.jpg", "./img/img_7.jpg", "./img/img_8.jpg", "./img/img_9.jpg", "./img/img_10.jpg",
// ];

// // // Preloader.series(images);
// // Preloader.parallel(images,0);

// class Temp {
//     addImageProcess(src){
//     return  new Promise((resolve, reject) => {
//             let img = new Image()
//             img.onload = () => resolve(img.height)
//             img.onerror = reject
//             img.src = src;
//         })
//     }
// }
// let tmp = new Temp()

// /* then - catch */
// tmp.addImageProcess(images[20]).then(height => {
//     console.log( height )
// }).catch( error => {
//     console.log( error )
// })

// /* async - await */
// async function logImageHeight(imageUrl) {
//     console.log( await tmp.addImageProcess(imageUrl) )
// }
// logImageHeight(images[0])

/* 비동기 함수 */
// const delay = () => {
//     const randomDelay = Math.floor(Math.random() * 4) * 100
//     return new Promise(resolve => setTimeout(resolve, randomDelay))
// }
// const list = [1,2,3,4,5];

/*
forEach 안에는 async await 을 써도 의미 없음.
비동기 함수가 바로바로 실행됨.. 이전 비동기 함수를 기다려주지 않음.
*/
// list.forEach(async data => {
//     console.log(data + " : forEach 요청 시작")
//     await delay()
//         .then(() => console.log(data))
//     console.log(data + " : forEach 요청 끝")
// })

/*
for of 는 비동기 함수를 기다려줌
함수가 실행되고 나면 다음 함수가 실행됨.. => 느림
1번 요청 > 1번 요청 끝 > 2번 요청 ...
*/
// const result = async (list) => {
//     for (const data of list) {
//         console.log(data + " : loop 요청 시작")
//         await delay()
//             .then(() => console.log(data))
//         console.log(data + " : loop 요청 끝")
//     }
// }
// result(list)

/*
map 은 promise 를 반환하고
Promise.all() 로 순차적 재생
1번 요청 > 2번 요청 > 3번 요청 ... 요청이 먼저 일어나고 처리를 순차적으로 진행
1번 처리 > 2번 처리 > 3번 처리
for of 처럼 순차적으로 진행되지만 빠르다.
*/
// const loop = async (list) => {
//     console.log("시작")
//     const promises = list.map(async data => {
//         console.log(data + " : 요청 시작")
//         return await delay()
//             .then(() => data)
//     })
    
//     const results = await Promise.all(promises)
    
//     results.forEach(data => console.log(data))
//     console.log("끝")
// }

// loop(list)

class AA {
    constructor () {}

    static aa(){ console.log('aa')}
    bb(){ console.log('bb') }
}

A = new AA()
// A.aa() // 오류
A.bb()
AA.aa()

    </script>
    
</body>
</html>